using Microsoft.Azure.Ipam.Client;
using Microsoft.Azure.Ipam.Contracts;

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Xml.XPath;
using static System.Console;

namespace FindInvalidIP
{
    enum ValidationStatus
    {
        Unknown,
        Success,
        NoMatch,            // No matching record found in Kusto
        EmptyTitle,
        EmptyDatacenter,
        NoneEopDcName,      // Azure name has no EOP name
        MismatchedDcName,   // Azure name does not match EOP name
        InvalidTitle,       // No environment/DC name in title
    }

    class Processor
    {
        internal IpamClient IpamClient { get; set; }

        private List<string> ipHotList = new List<string>();

        /// <summary>
        /// Processes input XML file and checks against IPAM for invalid IP addresses.
        /// </summary>
        /// <param name="resultFile">Result XML file generated by the FindIPTags applet.</param>
        /// <remarks>
        /// Output is in CSV format.
        /// </remarks>
        internal async Task Process(string resultFile)
        {
            // CSV header row
            WriteLine("Envionment,IP Range,Status");
 
            var sep = new[] { ',', ' ' };
            var xd = XDocument.Load(resultFile);
            //var debug = false;
            var tasks = new List<Task>();

            // Process non-configuration nodes first because
            // configuration nodes may have duplicate IP strings.
            var envNodes = xd.Root.XPathSelectElements("//file[not(starts-with(@path, '_'))]");
            foreach (var fileNode in envNodes)
            {
                tasks.Add(ProcessFileNode_(fileNode));
            }
            Task.WaitAll(tasks.ToArray());

            var configNodes = xd.Root.XPathSelectElements("//file[starts-with(@path, '_')]");
            foreach (var fileNode in configNodes)
            {
                await ProcessFileNode_(fileNode);
            }
            
            async Task ProcessFileNode_(XElement fileNode_)
            {
                var configName = fileNode_.Attribute("name").Value;
                var envName = ExtractEnvironmentName_(configName);
                var isConfigEnv = envName.StartsWith("_");
                string forestName = null;
                string eopDcName = null;
                if (!isConfigEnv)
                {
                    var index = envName.LastIndexOf('-');
                    if (index > 0)
                    {
                        forestName = envName.Substring(0, index);
                        eopDcName = envName.Substring(index + 1);
                    }
                }

                foreach (var node in fileNode_.Elements())
                {
                    foreach (var attr in node.Attributes())
                    {
                        if (attr.Name == "path") continue;
                        //if (debug) continue;
                        //else debug = true;

                        if (attr.Value.IndexOfAny(sep) > 0)
                        {
                            var a = attr.Value.Split(sep, StringSplitOptions.RemoveEmptyEntries);
                            foreach (var ipString in a)
                            {
                                await ProcessIP_(ipString);
                            }
                        }
                        else
                        {
                            await ProcessIP_(attr.Value);
                        }
                    }
                }

                async Task ProcessIP_(string ipString_)
                {
                    lock (ipHotList)
                    {
                        if (ipHotList.Contains(ipString_))
                        {
                            return;
                        }
                        else
                        {
                            ipHotList.Add(ipString_);
                        }
                    }

                    var result = await FindIP(forestName, eopDcName, ipString_);
                    if (result != ValidationStatus.Success)
                    {
                        WriteLine($"{envName},{ipString_},{result}");
                    }
                }
            }

            string ExtractEnvironmentName_(string filename)
            {
                var index = filename.LastIndexOf('.');
                if (index > 0) return filename.Substring(0, index);
                return filename;
            }
        }

        private string[] addressSpaceIds = new[] {
            SpecialAddressSpaces.DefaultAddressSpaceId,
            SpecialAddressSpaces.GalaCakeAddressSpaceId,
            SpecialAddressSpaces.EXAddressSpaceId,
            SpecialAddressSpaces.RXAddressSpaceId
            };

        async Task<ValidationStatus> FindIP(string forestName, string eopDcName, string ipString)
        {
            var isPrefix = ipString.Contains('/');
            foreach (var addressSpaceId in addressSpaceIds)
            {
                var result = await FindInAddressSpace_(SpecialAddressSpaces.DefaultAddressSpaceId);
                if (result == ValidationStatus.NoMatch) { continue; }
                return result;
            }
            return ValidationStatus.NoMatch;

            async Task<ValidationStatus> FindInAddressSpace_(string addressSpaceId_)
            {
                var queryModel = AllocationQueryModel.Create(addressSpaceId_, ipString);
                queryModel.ReturnParentWhenNotFound = !isPrefix;
                queryModel.MaxResults = 1000;

                var queryResult = await this.IpamClient.QueryAllocationsAsync(queryModel);
                var parent = queryResult.FirstOrDefault();
                if (parent != null)
                {
                    if (isPrefix)
                    {
                        // No need to validate tags of an IP range prefix.
                    }
                    else
                    {
                        var title = parent.Tags["Title"];
                        if (string.IsNullOrWhiteSpace(title))
                        {
                            return ValidationStatus.EmptyTitle;
                        }

                        var dcName = parent.Tags["Datacenter"];
                        if (string.IsNullOrWhiteSpace(dcName))
                        {
                            return ValidationStatus.EmptyDatacenter;
                        }
                        if (!title.ContainsText(dcName))
                        {
                            return ValidationStatus.InvalidTitle;
                        }

                        var mappeEopDcName = GetEopDcName(dcName);
                        if (string.IsNullOrWhiteSpace(mappeEopDcName))
                        {
                            return ValidationStatus.NoneEopDcName;
                        }
                        if (!string.IsNullOrWhiteSpace(eopDcName) && 
                            !eopDcName.IsSameTextAs(mappeEopDcName))
                        {
                            return ValidationStatus.MismatchedDcName;
                        }

                        if (!string.IsNullOrWhiteSpace(forestName) &&
                            !title.ContainsText(forestName)
                            )
                        {
                            //return ValidationStatus.InvalidTitle;
                        }
                    }
                    return ValidationStatus.Success;
                }
                return ValidationStatus.NoMatch;
            }
        }

        private XDocument dcNameTable;
        private XDocument DcNameTable
        {
            get
            {
                if (dcNameTable == null)
                {
                    var myType = this.GetType();
                    var rcName = myType.Namespace + ".Files.DCNAMES.xml";
                    using (var rcs = myType.Assembly.GetManifestResourceStream(rcName))
                    {
                        dcNameTable = XDocument.Load(rcs);
                    }
                }
                return dcNameTable;
            }
        }

        private string GetEopDcName(string azureName)
        {
            var node = this.DcNameTable.XPathSelectElement($"//DCNAME[@AZURENAME='{azureName}']");
            return node?.Attribute("EOPNAME").Value;
        }

    }
}
